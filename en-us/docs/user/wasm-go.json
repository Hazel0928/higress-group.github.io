{
  "filename": "wasm-go.md",
  "__html": "<h1>Implement a WASM plugin with Golang</h1>\n<h1>1. Prepare Development Tools</h1>\n<p>First, install Golang and Tinygo.\n<a name=\"a81fa\"></a></p>\n<h2>1. Golang</h2>\n<p>Min Version: 1.18<br />Official download link: <a href=\"https://go.dev/doc/install\">https://go.dev/doc/install</a>\n<a name=\"JFoN6\"></a></p>\n<h3>Windows</h3>\n<ol>\n<li>Download the installer: <a href=\"https://go.dev/dl/go1.19.windows-amd64.msi\">https://go.dev/dl/go1.19.windows-amd64.msi</a></li>\n<li>Run the downloaded installer to start the installation. It will be installed to <code>Program Files</code> or <code>Program Files (x86)</code> folder by default.</li>\n<li>After completed the installation, open &quot;Run&quot; dialog with hotkey &quot;Win+R&quot;. Type &quot;cmd&quot; in the dialog and click &quot;OK&quot; to open Command Line Prompt. Type: <code>go version</code>. If version info is displayed, the package has been successfully installed.\n<a name=\"tavPX\"></a></li>\n</ol>\n<h3>MacOS</h3>\n<ol>\n<li>Download the installer: <a href=\"https://go.dev/dl/go1.19.darwin-amd64.pkg\">https://go.dev/dl/go1.19.darwin-amd64.pkg</a></li>\n<li>Run the downloaded installer to start the installation. It will be installed to <code>/usr/local/go</code> folder by default.</li>\n<li>Open Terminal and type: <code>go version</code>. If version info is displayed, the package has been successfully installed.\n<a name=\"olPlT\"></a></li>\n</ol>\n<h3>Linux</h3>\n<ol>\n<li>Download the installer: <a href=\"https://go.dev/dl/go1.19.linux-amd64.tar.gz\">https://go.dev/dl/go1.19.linux-amd64.tar.gz</a></li>\n<li>Execute following commands to start the installation:</li>\n</ol>\n<pre><code class=\"language-bash\">rm -rf /usr/<span class=\"hljs-built_in\">local</span>/go &amp;&amp; tar -C /usr/<span class=\"hljs-built_in\">local</span> -xzf go1.19.linux-amd64.tar.gz\n<span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$PATH</span>:/usr/<span class=\"hljs-built_in\">local</span>/go/bin\n</code></pre>\n<ol start=\"3\">\n<li>Execute <code>go version</code>. If version info is displayed, the package has been successfully installed.</li>\n</ol>\n<p><a name=\"qugm0\"></a></p>\n<h2>2. TinyGo</h2>\n<p>Min Version: 0.25.0<br />Official download link: <a href=\"https://tinygo.org/getting-started/install/\">https://tinygo.org/getting-started/install/</a>\n<a name=\"ELNis\"></a></p>\n<h3>Windows</h3>\n<ol>\n<li>Download the package: <a href=\"https://github.com/tinygo-org/tinygo/releases/download/v0.25.0/tinygo0.25.0.windows-amd64.zip\">https://github.com/tinygo-org/tinygo/releases/download/v0.25.0/tinygo0.25.0.windows-amd64.zip</a></li>\n<li>Unpack the package to the target folder</li>\n<li>If the package is unpacked to folder <code>C:\\tinygo</code>, you need to add <code>C:\\tinygo\\bin</code> into the environment variable <code>PATH</code>, using set command in Command Line Prompt for example.</li>\n</ol>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">set</span> PATH=%PATH%;<span class=\"hljs-string\">\"C:\\tinygo\\bin\"</span>;\n</code></pre>\n<ol start=\"4\">\n<li>Execute <code>tinygo version</code> command in Command Line Prompt. If version info is displayed, the package has been successfully installed.\n<a name=\"iCo9z\"></a></li>\n</ol>\n<h3>MacOS</h3>\n<ol>\n<li>Download and unpack the package</li>\n</ol>\n<pre><code class=\"language-bash\">wget https://github.com/tinygo-org/tinygo/releases/download/v0.25.0/tinygo0.25.0.darwin-amd64.tar.gz\ntar -zxf tinygo0.25.0.darwin-amd64.tar.gz\n</code></pre>\n<ol start=\"2\">\n<li>If the package is unpacked to folder <code>/tmp</code>, you need to add <code>/tmp/tinygo/bin</code> to the environment variable <code>PATH</code>:</li>\n</ol>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">export</span> PATH=/tmp/tinygo/bin:<span class=\"hljs-variable\">$PATH</span>\n</code></pre>\n<ol start=\"3\">\n<li>Execute command <code>tinygo version</code> in Terminal.  If version info is displayed, the package has been successfully installed.\n<a name=\"hNZeF\"></a></li>\n</ol>\n<h3>Linux</h3>\n<p>Following steps are based on Ubuntu AMD64. For other OSes, please refer to the official document.</p>\n<ol>\n<li>Download and install the DEB package.</li>\n</ol>\n<pre><code class=\"language-bash\">wget https://github.com/tinygo-org/tinygo/releases/download/v0.25.0/tinygo_0.25.0_amd64.deb\nsudo dpkg -i tinygo_0.25.0_amd64.deb\n<span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$PATH</span>:/usr/<span class=\"hljs-built_in\">local</span>/bin\n</code></pre>\n<ol start=\"2\">\n<li>Execute command <code>tinygo version</code> in Terminal. If version info is displayed, the package has been successfully installed.</li>\n</ol>\n<p><a name=\"QZbcA\"></a></p>\n<h1>2. Write a plugin</h1>\n<p><a name=\"u83FM\"></a></p>\n<h2>1. Initialize the project</h2>\n<p>You can create your wasm-go plugin directory in the repo <a href=\"https://github.com/alibaba/higress\">higress</a>'s <a href=\"https://github.com/alibaba/higress/tree/main/plugins/wasm-go\">plugins/wasm-go</a>\nthat you can use the scaffolding tools provided in this directory（see 1.1）；\nor create a new directory for your Go project yourself(see 1.2).\nIf you are developing wasm-go plugins for the first time, it is recommended to take the former.</p>\n<h3>1.1 create wasm-go plugin in <a href=\"https://github.com/alibaba/higress/tree/main/plugins/wasm-go\">plugins/wasm-go</a></h3>\n<ol>\n<li><code>git clone https://github.com/alibaba/higress.git</code>, to clone project to local；</li>\n<li><code>cd plugins/wasm-go; mkdir wasm-demo-go</code>, to go to the project's plugins/wasm-go directory and create the wasm-demo-go directory.</li>\n</ol>\n<h3>1.2 create a new project yourself</h3>\n<ol>\n<li>Create a new folder for the project. For example: <code>wasm-demo-go</code>.</li>\n<li>Execute following commands in the new folder to initialize the Go project:</li>\n</ol>\n<pre><code class=\"language-bash\">go mod init wasm-demo-go\n</code></pre>\n<ol start=\"3\">\n<li>If you are in the Chinese mainland, you may need to set a proxy for downloading dependencies.</li>\n</ol>\n<pre><code class=\"language-bash\">go env -w GOPROXY=https://proxy.golang.com.cn,direct\n</code></pre>\n<ol start=\"4\">\n<li>Download dependencies for plugin building.</li>\n</ol>\n<pre><code class=\"language-bash\">go get github.com/tetratelabs/proxy-wasm-go-sdk\ngo get github.com/alibaba/higress/plugins/wasm-go@main\ngo get github.com/tidwall/gjson\n</code></pre>\n<p><a name=\"Z2lFM\"></a></p>\n<h2>2. Write main.go</h2>\n<p>You can find a simple sample below, which provides following functions:</p>\n<ol>\n<li>If <code>mockEnable</code> is set to <code>true</code>, send <code>hello world</code> directly as the response.</li>\n<li>If <code>mockEnable</code> is not set or set to <code>false</code>, add an extra HTTP header <code>hello: world</code> to the original request.\nMore samples can be found in section 4 below.</li>\n</ol>\n<blockquote>\n<p>Note: Plugin configurations use YAML format in the gateway console. But plugins receive them in JSON format. So in the sample below, actual config data are extracted from JSON by the <code>parseConfig</code> function.</p>\n</blockquote>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n        <span class=\"hljs-string\">\"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper\"</span>\n        <span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm\"</span>\n        <span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm/types\"</span>\n        <span class=\"hljs-string\">\"github.com/tidwall/gjson\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n        wrapper.SetCtx(\n                <span class=\"hljs-comment\">// Plugin name</span>\n                <span class=\"hljs-string\">\"my-plugin\"</span>,\n                <span class=\"hljs-comment\">// A custom function for parsing plugin configurations</span>\n                wrapper.ParseConfigBy(parseConfig),\n                <span class=\"hljs-comment\">// A custom function for processing request headers</span>\n                wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders),\n        )\n}\n\n<span class=\"hljs-comment\">// Custom plugin configuration</span>\n<span class=\"hljs-keyword\">type</span> MyConfig <span class=\"hljs-keyword\">struct</span> {\n        mockEnable <span class=\"hljs-keyword\">bool</span>\n}\n\n<span class=\"hljs-comment\">// Plugin configurations set in the console with YAML format will be converted to JSON. So we just need to parse config data from JSON.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">parseConfig</span><span class=\"hljs-params\">(json gjson.Result, config *MyConfig, log wrapper.Log)</span> <span class=\"hljs-title\">error</span></span> {\n        <span class=\"hljs-comment\">// Get the configuration property and set to the config object.</span>\n    \tconfig.mockEnable = json.Get(<span class=\"hljs-string\">\"mockEnable\"</span>).Bool()\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">onHttpRequestHeaders</span><span class=\"hljs-params\">(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log)</span> <span class=\"hljs-title\">types</span>.<span class=\"hljs-title\">Action</span></span> {\n        proxywasm.AddHttpRequestHeader(<span class=\"hljs-string\">\"hello\"</span>, <span class=\"hljs-string\">\"world\"</span>)\n        <span class=\"hljs-keyword\">if</span> config.mockEnable {\n                proxywasm.SendHttpResponse(<span class=\"hljs-number\">200</span>, <span class=\"hljs-literal\">nil</span>, []<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-string\">\"hello world\"</span>), <span class=\"hljs-number\">-1</span>)\n        }\n        <span class=\"hljs-keyword\">return</span> types.ActionContinue\n}\n</code></pre>\n<p><a name=\"SYNZJ\"></a></p>\n<h3>HTTP Processing Pointcuts</h3>\n<p>In the sample above, <code>wrapper.ProcessRequestHeadersBy</code> applies custom function <code>onHttpRequestHeaders</code> when processing requests in<code>HTTP request header processing stage</code>. Besides that, you can use following methods to set custom processing functions for various stages.</p>\n<table>\n<thead>\n<tr>\n<th>HTTP Processing Stage</th>\n<th>Trigger Time</th>\n<th>Pointcut Mounting Method</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTTP request header processing stage</td>\n<td>When gateway receives request headers from client</td>\n<td>wrapper.ProcessRequestHeadersBy</td>\n</tr>\n<tr>\n<td>HTTP request body processing stage</td>\n<td>When gateway receives request body from client</td>\n<td>wrapper.ProcessRequestBodyBy</td>\n</tr>\n<tr>\n<td>HTTP response header processing stage</td>\n<td>When gateway receives response headers from upstream</td>\n<td>wrapper.ProcessResponseHeadersBy</td>\n</tr>\n<tr>\n<td>HTTP response body processing stage</td>\n<td>When gateway receives response body from upstream</td>\n<td>wrapper.ProcessResponseBodyBy</td>\n</tr>\n</tbody>\n</table>\n<p><a name=\"r6rK5\"></a></p>\n<h3>Utility Functions</h3>\n<p>In the sample above, <code>proxywasm.AddHttpRequestHeader</code> and <code>proxywasm.SendHttpResponse</code> are two utility methods provided by the plugin SDK. You can find major utility functions in the table below:</p>\n<table>\n<thead>\n<tr>\n<th>Category</th>\n<th>Name</th>\n<th>Usage</th>\n<th>Available<br />HTTP Processing Stage(s)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Request Header Processing</td>\n<td>GetHttpRequestHeaders</td>\n<td>Get all the request headers sent by the client</td>\n<td>HTTP request header processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpRequestHeaders</td>\n<td>Replace all headers in the request.</td>\n<td>HTTP request header processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>GetHttpRequestHeader</td>\n<td>Get the specified header in the request.</td>\n<td>HTTP request header processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>RemoveHttpRequestHeader</td>\n<td>Remove the specified header from the request.</td>\n<td>HTTP request header processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpRequestHeader</td>\n<td>Replace the specified header in the response.</td>\n<td>HTTP request header processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>AddHttpRequestHeader</td>\n<td>Add a new header to the request.</td>\n<td>HTTP request header processing stage</td>\n</tr>\n<tr>\n<td>Request Body Processing</td>\n<td>GetHttpRequestBody</td>\n<td>Get the request body received from client.</td>\n<td>HTTP request body processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>AppendHttpRequestBody</td>\n<td>Append the specified binary data to the request body.</td>\n<td>HTTP request body processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>PrependHttpRequestBody</td>\n<td>Prepend the specified binary data to the request body.</td>\n<td>HTTP request body processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpRequestBody</td>\n<td>Replace the entire request body received from client.</td>\n<td>HTTP request body processing stage</td>\n</tr>\n<tr>\n<td>Response Header Processing</td>\n<td>GetHttpResponseHeaders</td>\n<td>Get all the response headers received from upstream.</td>\n<td>HTTP response header processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpResponseHeaders</td>\n<td>Replace all headers in the response.</td>\n<td>HTTP response header processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>GetHttpResponseHeader</td>\n<td>Get the specified header in the response.</td>\n<td>HTTP response header processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>RemoveHttpResponseHeader</td>\n<td>Remove the specified header from the response.</td>\n<td>HTTP response header processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpResponseHeader</td>\n<td>Replace the specified header in the response.</td>\n<td>HTTP response header processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>AddHttpResponseHeader</td>\n<td>Add a new header to the response.</td>\n<td>HTTP response header processing stage</td>\n</tr>\n<tr>\n<td>Response Body Processing</td>\n<td>GetHttpResponseBody</td>\n<td>Get the response body received from upstream.</td>\n<td>HTTP response body processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>AppendHttpResponseBody</td>\n<td>Append the specified binary data to the response body.</td>\n<td>HTTP response body processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>PrependHttpResponseBody</td>\n<td>Prepend the specified binary data to the response body.</td>\n<td>HTTP response body processing stage</td>\n</tr>\n<tr>\n<td></td>\n<td>ReplaceHttpResponseBody</td>\n<td>Replace the entire response body with specific data.</td>\n<td>HTTP response body processing stage</td>\n</tr>\n<tr>\n<td>HTTP Call</td>\n<td>DispatchHttpCall</td>\n<td>Send an HTTP request.</td>\n<td>-</td>\n</tr>\n<tr>\n<td></td>\n<td>GetHttpCallResponseHeaders</td>\n<td>Get the response headers associated with a DispatchHttpCall call.</td>\n<td>-</td>\n</tr>\n<tr>\n<td></td>\n<td>GetHttpCallResponseBody</td>\n<td>Get the response body associated with a DispatchHttpCall call.</td>\n<td>-</td>\n</tr>\n<tr>\n<td></td>\n<td>GetHttpCallResponseTrailers</td>\n<td>Get the response trailer associated with a DispatchHttpCall call.</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Respond Directly</td>\n<td>SendHttpResponse</td>\n<td>Return a specific HTTP response immediately.</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Process Resuming</td>\n<td>ResumeHttpRequest</td>\n<td>Resume the request processing workflow paused before.</td>\n<td>-</td>\n</tr>\n<tr>\n<td></td>\n<td>ResumeHttpResponse</td>\n<td>Resume the response processing workflow paused before.</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<p><a name=\"GAa0T\"></a></p>\n<h2>3. Build WASM file</h2>\n<p>If your project directory is in the <a href=\"https://github.com/alibaba/higress/tree/main/plugins/wasm-go\">plugins/wasm-go</a> directory\nSee 3.1; if you are using a self-initialized directory, see 3.2.</p>\n<h3>3.1 Building wasm-go plugin image with scaffolding</h3>\n<p>The wasm-go plugin can be built quickly with the following command:</p>\n<pre><code class=\"language-bash\">$ PLUGIN_NAME=wasm-demo-go make build\n... ...\nimage:            wasm-demo-go:20230223-173305-3b1a471\noutput wasm file: extensions/wasm-demo-go/plugin.wasm\n</code></pre>\n<p>This command eventually builds a wasm file and a Docker image.\nThis local wasm file is exported to the specified plugin's directory and can be used directly for local debugging.\nYou can also use <code>make build-push</code> to build and push the image together.\nSee <a href=\"https://github.com/alibaba/higress/tree/main/plugins/wasm-go\">plugins/wasm-go</a> for more.</p>\n<h3>3.2 Compile wasm files locally</h3>\n<p>Execute the following command:</p>\n<pre><code class=\"language-bash\">tinygo build -o main.wasm -scheduler=none -target=wasi ./main.go\n</code></pre>\n<p>A new file named main.wasm will be created after a successful compilation, which will be used in the local debugging sample below as well.<br />When using custom plugin function in the cloud native gateway market, you just need to upload this file.</p>\n<p><a name=\"yJdN5\"></a></p>\n<h1>3. Local Debugging</h1>\n<p>TBD</p>\n<h1>More Samples</h1>\n<p><a name=\"vdifW\"></a></p>\n<h2>Plugin with No Configuration</h2>\n<p>If the plugin needs no configuration, just define an empty config struct.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n        <span class=\"hljs-string\">\"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper\"</span>\n        <span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm\"</span>\n        <span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm/types\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n        wrapper.SetCtx(\n                <span class=\"hljs-string\">\"hello-world\"</span>,\n                wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders),\n        )\n}\n\n<span class=\"hljs-keyword\">type</span> MyConfig <span class=\"hljs-keyword\">struct</span> {}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">onHttpRequestHeaders</span><span class=\"hljs-params\">(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log)</span> <span class=\"hljs-title\">types</span>.<span class=\"hljs-title\">Action</span></span> {\n        proxywasm.SendHttpResponse(<span class=\"hljs-number\">200</span>, <span class=\"hljs-literal\">nil</span>, []<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-string\">\"hello world\"</span>), <span class=\"hljs-number\">-1</span>)\n        <span class=\"hljs-keyword\">return</span> types.ActionContinue\n}\n</code></pre>\n<p><a name=\"dSdLn\"></a></p>\n<h2>Send Requests to External Services in the Plugin</h2>\n<p>Only HTTP requests are supported for now. You can send requests to Nacos and K8s services with service sources configured in the gateway console, and services with a static IP or DNS source. Please be noted, HTTP client in the <code>net/http</code> package cannot be used here. You only use the wrapped HTTP client as shown in the sample below.<br />In the following sample works as below:</p>\n<ol>\n<li>Parse service type in the config parsing stage, and generate the corresponding HTTP client.</li>\n<li>In the HTTP request header processing stage, send a service request to the configured URL.</li>\n<li>Parse response headers and get token value using the specified key.</li>\n<li>Set the token value to the headers of the original request.</li>\n</ol>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"errors\"</span>\n\t<span class=\"hljs-string\">\"net/http\"</span>\n\t<span class=\"hljs-string\">\"strings\"</span>\n\n    <span class=\"hljs-string\">\"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper\"</span>\n\t<span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm\"</span>\n\t<span class=\"hljs-string\">\"github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm/types\"</span>\n\t<span class=\"hljs-string\">\"github.com/tidwall/gjson\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\twrapper.SetCtx(\n\t\t<span class=\"hljs-string\">\"http-call\"</span>,\n\t\twrapper.ParseConfigBy(parseConfig),\n\t\twrapper.ProcessRequestHeadersBy(onHttpRequestHeaders),\n\t)\n}\n\n<span class=\"hljs-keyword\">type</span> MyConfig <span class=\"hljs-keyword\">struct</span> {\n\t<span class=\"hljs-comment\">// The client used to initiate an HTTP request</span>\n\tclient      wrapper.HttpClient\n\t<span class=\"hljs-comment\">// Request URL</span>\n\trequestPath <span class=\"hljs-keyword\">string</span>\n\t<span class=\"hljs-comment\">// Use this key when extracting token header from the service response and setting a header to the request. The value is configurable.</span>\n\ttokenHeader <span class=\"hljs-keyword\">string</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">parseConfig</span><span class=\"hljs-params\">(json gjson.Result, config *MyConfig, log wrapper.Log)</span> <span class=\"hljs-title\">error</span></span> {\n\tconfig.tokenHeader = json.Get(<span class=\"hljs-string\">\"tokenHeader\"</span>).String()\n\t<span class=\"hljs-keyword\">if</span> config.tokenHeader == <span class=\"hljs-string\">\"\"</span> {\n\t\t<span class=\"hljs-keyword\">return</span> errors.New(<span class=\"hljs-string\">\"missing tokenHeader in config\"</span>)\n\t}\n\tconfig.requestPath = json.Get(<span class=\"hljs-string\">\"requestPath\"</span>).String()\n\t<span class=\"hljs-keyword\">if</span> config.requestPath == <span class=\"hljs-string\">\"\"</span> {\n\t\t<span class=\"hljs-keyword\">return</span> errors.New(<span class=\"hljs-string\">\"missing requestPath in config\"</span>)\n\t}\n\tserviceSource := json.Get(<span class=\"hljs-string\">\"serviceSource\"</span>).String()\n\t<span class=\"hljs-comment\">// If serviceSource is set to \"ip\" or \"dns\", serviceName shall be specified when creating the service.</span>\n\t<span class=\"hljs-comment\">// If serviceSource is set to \"nacos\" or \"k8s\", serviceName shall be set to the original name specified when registering the service.</span>\n\tserviceName := json.Get(<span class=\"hljs-string\">\"serviceName\"</span>).String()\n\tservicePort := json.Get(<span class=\"hljs-string\">\"servicePort\"</span>).Int()\n\t<span class=\"hljs-keyword\">if</span> serviceName == <span class=\"hljs-string\">\"\"</span> || servicePort == <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> errors.New(<span class=\"hljs-string\">\"invalid service config\"</span>)\n\t}\n\t<span class=\"hljs-keyword\">switch</span> serviceSource {\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"k8s\"</span>:\n\t\tnamespace := json.Get(<span class=\"hljs-string\">\"namespace\"</span>).String()\n\t\tconfig.client = wrapper.NewClusterClient(wrapper.K8sCluster{\n\t\t\tServiceName: serviceName,\n\t\t\tNamespace:   namespace,\n\t\t\tPort:        servicePort,\n\t\t})\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"nacos\"</span>:\n\t\tnamespace := json.Get(<span class=\"hljs-string\">\"namespace\"</span>).String()\n\t\tconfig.client = wrapper.NewClusterClient(wrapper.NacosCluster{\n\t\t\tServiceName: serviceName,\n\t\t\tNamespaceID: namespace,\n\t\t\tPort:        servicePort,\n\t\t})\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"ip\"</span>:\n\t\tconfig.client = wrapper.NewClusterClient(wrapper.StaticIpCluster{\n\t\t\tServiceName: serviceName,\n\t\t\tPort:        servicePort,\n\t\t})\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"dns\"</span>:\n\t\tdomain := json.Get(<span class=\"hljs-string\">\"domain\"</span>).String()\n\t\tconfig.client = wrapper.NewClusterClient(wrapper.DnsCluster{\n\t\t\tServiceName: serviceName,\n\t\t\tPort:        servicePort,\n\t\t\tDomain:      domain,\n\t\t})\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t<span class=\"hljs-keyword\">default</span>:\n\t\t<span class=\"hljs-keyword\">return</span> errors.New(<span class=\"hljs-string\">\"unknown service source: \"</span> + serviceSource)\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">onHttpRequestHeaders</span><span class=\"hljs-params\">(ctx wrapper.HttpContext, config MyConfig, log wrapper.Log)</span> <span class=\"hljs-title\">types</span>.<span class=\"hljs-title\">Action</span></span> {\n\t<span class=\"hljs-comment\">// Use the Get function of the client to initiate an HTTP Get request.</span>\n\t<span class=\"hljs-comment\">// The timeout parameter is omitted here, whose default value is 500ms.</span>\n\tconfig.client.Get(config.requestPath, <span class=\"hljs-literal\">nil</span>,\n\t\t<span class=\"hljs-comment\">// A callback function which will be called asynchronously when receiving the response.</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(statusCode <span class=\"hljs-keyword\">int</span>, responseHeaders http.Header, responseBody []<span class=\"hljs-keyword\">byte</span>)</span></span> {\n\t\t\t<span class=\"hljs-comment\">// Process the response with a status code other than 200.</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> statusCode != http.StatusOK {\n\t\t\t\tlog.Errorf(<span class=\"hljs-string\">\"http call failed, status: %d\"</span>, statusCode)\n\t\t\t\tproxywasm.SendHttpResponse(http.StatusInternalServerError, <span class=\"hljs-literal\">nil</span>,\n\t\t\t\t\t[]<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-string\">\"http call failed\"</span>), <span class=\"hljs-number\">-1</span>)\n\t\t\t\t<span class=\"hljs-keyword\">return</span>\n\t\t\t}\n\t\t\t<span class=\"hljs-comment\">// Print out the status code and response body</span>\n\t\t\tlog.Infof(<span class=\"hljs-string\">\"get status: %d, response body: %s\"</span>, statusCode, responseBody)\n\t\t\t<span class=\"hljs-comment\">// Extract token value from the response header and set the header of the original request</span>\n\t\t\ttoken := responseHeaders.Get(config.tokenHeader)\n\t\t\t<span class=\"hljs-keyword\">if</span> token != <span class=\"hljs-string\">\"\"</span> {\n\t\t\t\tproxywasm.AddHttpRequestHeader(config.tokenHeader, token)\n\t\t\t}\n\t\t\t<span class=\"hljs-comment\">// Resume the original request processing workflow. Continue the process, so the request can be forwarded to the upstream.</span>\n\t\t\tproxywasm.ResumeHttpRequest()\n\t\t})\n\t<span class=\"hljs-comment\">// We need to wait for the callback to finish its process.</span>\n\t<span class=\"hljs-comment\">// Return Pause action here to pause the request processing workflow, which can be resumed by a ResumeHttpRequest call.</span>\n\t<span class=\"hljs-keyword\">return</span> types.ActionPause\n}\n</code></pre>\n",
  "link": "/en-us/docs/user/wasm-go.html",
  "meta": {
    "title": "Developing a WASM plugin with Golang",
    "keywords": "wasm",
    "description": "Developing a WASM plugin with Golang"
  }
}